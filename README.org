* prompt2
[[https://github.com/fimblo/prompt2/actions/workflows/ubuntu.yml/badge.svg]]
[[https://github.com/fimblo/prompt2/actions/workflows/macos.yml/badge.svg]]

prompt2 - Dynamic Shell Prompt Generator

I wrote prompt2 because I wanted a bash prompt which provided me with
a quick, real-time overview of the system's state from the command
line. Aside from the normal things one can find in PS1, such as
hostname and cwd, I wanted a prompt which behaved differently in a
normal directory and in a git repo. While doing this, I added other
features, like AWS authentication state.

It's easy to configure, and even supports named colours.


** Features
- *Performance*: Executes in under 100ms on older hardware (pre-2010
  with spinning disks) and around 10-13ms on modern machines equipped
  with SSDs.
- *Configuration*: Offers customisable prompt definitions, where
  widgets (content) and attributes (style) are separated - and
  configurable as well. All customisation is done in an INI file.
- *Cross-Platform Compatibility*: Supports both Debian/Ubuntu and
  macOS. Other systems should work - but you might need to fiddle with
  the =include= statements.
- *Extensibility*:  Designed with extensibility in mind, making it
  quite easy to add your own widgets - if you're willing to submit
  yourself to the somewhat masochistic craft known as C programming.
  
** Installation

Follow these steps to install prompt2 on your system.

| Note on the build instructions                                        |
|-----------------------------------------------------------------------|
| If the instructions below don't work for you, I advise that you check the  github action for your operating system([[.github/workflows/ubuntu.yml][Debian/Ubuntu]], [[.github/workflows/macos.yml][MacOS]]), since this should be up-to-date. |

*** Debian/Ubuntu:

#+begin_src bash
  # Install necessary dependencies
  sudo apt-get install build-essential git libgit2-dev libiniparser-dev libjson-c-dev uthash-dev
  sudo apt-get install bats

  # Clone the prompt2 repository
  git clone https://github.com/fimblo/prompt2.git

  # Navigate to the prompt2 directory
  cd prompt2

  # Compile the source and run tests
  make

  # Install prompt2 to ~/bin
  make install-local
#+end_src


*** macOS:

#+begin_src bash
  # Install Xcode Command Line Tools if not already installed
  xcode-select --install

  # Install Homebrew if not already installed
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

  # Install necessary dependencies using Homebrew
  brew install libgit2 json-c uthash iniparser
  brew install bats-core # for testing
  brew install bash # since macos vanilla bash is outdated


  # Clone the prompt2 repository
  git clone https://github.com/fimblo/prompt2.git

  # Navigate to the prompt2 directory
  cd prompt2

  # Compile the source and run tests
  make

  # Install prompt2 to ~/bin
  make install-local
#+end_src


The make command compiles the source and runs tests, ensuring
everything is set up correctly. If you prefer to install prompt2
globally, you can use =make install= to place the binaries in
=/usr/local/bin=. Use =make help= to see other available make targets
and options.

** Usage

To test prompt2, you can use the provided script
=config/set-prompt.ini.sh=. This will only make changes in your
current bash session:

#+begin_src bash
  source path/to/prompt2/config/set-prompt.ini.sh
#+end_src



Alternatively for a more permanent setup, copy the file
=config/dot.prompt2_config.ini= to =HOME=, removing the prefix along
the way:

#+begin_src bash
  cp path/to/prompt2/config/dot.prompt2_config.ini ~/.prompt2_config.ini
#+end_src

Then add this snippet into your =.bashrc=:

#+begin_src bash
  prompt_cmd() {
    PS1=$(prompt2)
  }
  PROMPT_COMMAND=prompt_cmd
#+end_src

** Customisation

Customising prompt2 involves modifying the INI configuration file to
adjust the appearance and behavior of the prompt components, known as
Widgets. The configuration file allows you to set various parameters
for each widget, such as text formatting, active and inactive states,
and style Attributes.

*** Defining your prompts

Currently, there are two prompts you can configure:
- *the git prompt*: applied when standing somewhere inside of a git
  repo. To configure this, add a =prompt= entry under the =PROMPT.GIT=
  section.
- *the default prompt*: in all other situations. To configure this,
  add a =prompt= entry under the =PROMPT.DEFAULT= section.

For example, a minimal prompt setup could look like this:

#+begin_src conf
  [PROMPT.DEFAULT]
  prompt="default $ "

  [PROMPT.GIT]
  prompt="git $ "
#+end_src

This snippet would, if applied to your shell, result in the prompt
=default $= and =git $= respectively.

But this is no fun, so let's add a dynamic element to these prompts.
These dynamic instructions are called Widgets. Each Widget is wrapped
like so: =@{widgetname}= and are at runtime replaced with whatever
they represent at the time.

#+begin_src conf
  ; show the current working directory, then
  ; add the prompt character '$' change depending on if you're root or not
  [PROMPT.DEFAULT]
  prompt="@{CWD} @{SYS.promptchar} "

  [PROMPT.GIT]
  prompt="@{CWD} @{SYS.promptchar} "
#+end_src

Now let's make these act differently:

#+begin_src conf
  [PROMPT.DEFAULT]
  prompt="Default: @{CWD} @{SYS.promptchar} "

  [PROMPT.GIT]
  prompt="Git: @{CWD} @{SYS.promptchar} "
#+end_src

CWD is shorthand for 'Current Working Directory' - that is, the name
of the directory you're standing in. This can traditionally be shown
in one of two ways: the full path from the root of the file system or
the path starting from your HOME directory.

prompt2 supports four styles of CWD:
  - =home=: show the path from your home directory. This is used if
    =cwd_type= is unset.
  - =basename=: show only the name of the directory you're standing
    in.
  - =full=: show the full path from /
  - =git=: show the path from the root of the git repo. 

You can modify the CWD style for your prompts:

#+begin_src conf
  [PROMPT.DEFAULT]
  prompt="Default: @{CWD} @{SYS.promptchar} "

  [PROMPT.GIT]
  prompt="Git: @{CWD} @{SYS.promptchar} "
  cwd_type="git"
#+end_src

In the example above, you will get the traditional path from HOME when
wandering about your file-system, but when you enter a git repo the
CWD will show your location in relation to the root of the repo.

Before we dive into widgets and how to configure them, let's take a
short detour and talk about Attributes...

*** Style Attributes

Typically referred to as Attributes, these are style instructions
which you can add to the prompt or Widget configuration. An attribute
starts with a =%= followed by curly braces, and contains an
instruction. It could look like this =%{bold}=. All attributes are
case-insensitive.

**** Text attributes

To change the style of the font, you can use these attributes. These
are: =bold=, =dim=, =italic=, =underline=, =blink=, =reverse=,
=hidden=, =strikethrough=.


Here we change the default prompt style by making everything
strike-through, as the cool kids do:

#+begin_src conf
  [PROMPT.DEFAULT]
  prompt="%{Strikethrough}My prompt%{Reset} $ "
#+end_src

**** Reset attributes

Used to reset part or all of the set attributes. These are: =reset=,
=reset bold/dim=, =reset italic=, =reset underline=, =reset blink=,
=reset reverse=, =reset hidden=, =reset fg=, =reset bg=.

The empty attribute =%{}= is shorthand for =%{reset}=.

**** Reserved colour slot attributes

Modern terminals have eight reserved colours: black, red, green,
yellow, blue, magenta, cyan, and white. The actual colours may vary
depending on your terminal settings but retain their slot names.

You can also refer to these slots by the slot number, zero-indexed.

To differentiate between foreground and background colours, prefix with
=fg= or =bg=.


| by name    |            | by slot    |            |
| ---------- | ---------- | ---------- | ---------- |
| foreground | background | foreground | background |
| ---------- | ---------- | ---------- | ---------- |
| fg black   | bg black   | fg c0      | bg c0      |
| fg red     | bg red     | fg c1      | bg c1      |
| fg green   | bg green   | fg c2      | bg c2      |
| fg yellow  | bg yellow  | fg c3      | bg c3      |
| fg blue    | bg blue    | fg c4      | bg c4      |
| fg magenta | bg magenta | fg c5      | bg c5      |
| fg cyan    | bg cyan    | fg c6      | bg c6      |
| fg white   | bg white   | fg c7      | bg c7      |


#+begin_src conf
  [PROMPT.DEFAULT]
  # blue and yellow foreground text
  prompt="%{fg blue}My %{fg c4}prompt%{reset}$ "
#+end_src

Note: each of the above have a corresponding =bright= version. So you
can get a bright magenta background by writing =bg bright magenta= or
=bg bright c5=

**** Named RGB codes

Using a terminal palette is useful, but sometimes you might want to
There are 658 named full RGB colours. These names come from the
[[https://en.wikipedia.org/wiki/X11_color_names][original X11 colour-set]] which can be found littering the internet. The
file and its license can be found in the [[etc/][etc/]] directory of this
project.

Using these are easy - prefix the colour name with =fg-= or =bg-= to
indicate if you want to colour the text or the background. The hyphen
is needed to differentiate from the named reserved colours.

#+begin_src conf
  [PROMPT.DEFAULT]
  # Cadet Blue text, with empty attribute to reset the colour
  prompt="%{fg-cadetblue}TEXT%{} $ "
#+end_src

Note: it's sometimes hard to know what colours look nice. I've
supplied a small script in =scripts/print_colours.pl= which prints all
the colours with their names. Run it in your terminal like this:
  
#+begin_src bash
  $ path/to/repo/scripts/print_colours.pl
#+end_src

**** Combining attributes

To save space and to avoid cognitive overload, it's possible to
combine attributes. For example, if you want:
- foreground palegreen2
- background grey10
- bold
- strikethrough

Then you can do this:

#+begin_src conf
  [PROMPT.DEFAULT]
  prompt="%{fg-palegreen2, bg-grey10, bold, strikethrough}TEXT%{} $ "
#+end_src

**** Note: Plain terminal escape codes

These aren't really attributes - it's just the normal terminal escape
codes. If you want to insert a terminal bell (=\[\a\]=) or for some
reason want to use the escape sequence for an RGB colour
(=\[\e[38;2;30;30;30\]=), prompt2 will ignore this as long as you wrap
the code in escaped brackets as specified in the section =[PROMPTING]=
in the bash man-page.
*** Widgets

Widgets are the dynamic elements in your prompt. We've already seen
two types: =@{CWD}= and =@{SYS.promptchar}= - but there's many more:

#+begin_example
CWD                          # current working directory
Repo.is_git_repo             # if . is a git repo
Repo.name                    # name of git repo
Repo.branch_name             # name of branch
Repo.rebase_active           # if rebase is in progress
Repo.conflicts               # number of conflicts in repo
Repo.ahead                   # number of commits ahead of remote
Repo.behind                  # number of commits behind remote
Repo.staged                  # number of staged files
Repo.modified                # number of changed modified files
Repo.untracked               # number of untracked files
AWS.token_is_valid           # if there is a valid AWS SSO token
AWS.token_remaining_hours    # AWS SSO token: how many hours are remaining
AWS.token_remaining_minutes  # AWS SSO token: how many minutes are remaining
SYS.username                 # username
SYS.hostname                 # hostname
SYS.uid                      # the effective uid of the user
SYS.gid                      # the effective gid of the user
SYS.promptchar               # set to '#' if the uid==0, '$' otherwise
SPC                          # spacefiller (see below)
#+end_example

All but the =@{SPC}= can be active or inactive. Each of these two
states have its own text replacement and colour.


Notes on two special widgets:
- =CWD=: This widget, which prints the path to your location in the
  filesystem, will automatically be truncated if the path won't fit in
  your terminal.
- =SPC=: Can be used once on each line of the prompt to align the
  remaining widgets to the right of the terminal.

All widgets are case-insensitive.

*** Customising Widgets

So far, we've only been configuring the prompt itself. But you can
also configure the widgets themselves - what the widgets should be
replaced with when active or inactive and what colours to use.

To customise the Default settings for all widgets, you can modify its
settings in the INI file as follows:

The default hard-coded config looks like this:

- =max_width=: 256 characters
- =string_active=: the format string "%s"
- =string_inactive=: the format string "%s"
- =colour_on=: no style
- =colour_off=: no style

These can be overridden with your own defaults, by creating your own
=[WIDGET_DEFAULT]= section like this:

#+begin_src conf
  [WIDGET_DEFAULT]
  max_width=128              # shorten if longer than this
  string_active="%s"
  string_inactive="%s"
  colour_on="%{fg bright cyan}"
  colour_off="%{fg cyan; dim}"
#+end_src

- =max_width=: The space a widget takes in the prompt, sans terminal
  escape codes. All widgets will be shortened on the right edge except
  for CWD where the beginning is cut away. Like mentioned above, CWD
  is automatically shortened if it doesn't fit in the terminal (so you
  only need to set =max_width= if you want to).

- =string_active= and =string_inactive=: These parameters define the
  format strings used when the widget is active or inactive. It's
  inserted directly into the printf (or snprintf) function, so you can
  use what you know from that, if you want. Otherwise, the important
  thing is that =%s= is the placeholder for the value of the widget.
  Use that and you'll be all set.

- =colour_on= and =colour_off=: These parameters control the text
  attributes for the active and inactive states of the widget. See
  [[#style-attributes][Style Attributes]] for details on what these are.

  For example, to set the foreground colour to a specific shade of blue
  using RGB values, you would use:
  
  #+begin_src conf
  colour_on="%{fg-goldenrod}"  # A nice shade of gold
  #+end_src

  Similarly, to set a background colour using RGB, you might use:
  
  #+begin_src conf
  colour_off="%{bg-grey10}"  # A dark background
  #+end_src


**** Overriding the default widget

Each individual widget can override the default config, for example
for =Repo.branch_name= here, where we normally would shorten longer
branch names to save space in the terminal.

#+begin_src conf
  [Repo.branch_name]
  max_width=20
#+end_src

We might also want to override =string_inactive= to show a hyphen if
there is no defined branch name yet. Remember: the other settings are
inherited from the default, so we don't need to tell it to print the
branch name if there is one.
#+begin_src conf
  [Repo.branch_name]
  max_width=20
  string_inactive="-"
#+end_src

Here's another example, where prompt2 will only show the conflict
widget if there is a git conflict. In other situations, it will not be
visible.

#+begin_src conf
  [Repo.conflicts]
  string_active="<conflicts: %s>"
  string_inactive=""
  colour_on="%{fg-orangeRed1}"
  colour_off=""
#+end_src

**** Nesting widgets

prompt2 supports nested widgets (only one layer deep). Here's an
example with some annotation to make things a little easier to
understand.

#+begin_src conf
  # Here we have a simple prompt which has one widget in it -
  # =AWS.token_is_valid=. This widget is active if you have a valid aws
  # token right now.

  [PROMPT.DEFAULT]
  prompt="@{AWS.token_is_valid} $ "

  # The widget in question will, if active (valid token), be replaced
  # with the two widgets below, with some decorations.
  # As you can see, when it's inactive, then it's replaced with nothing.
  [AWS.token_is_valid]
  string_active="<@{AWS.token_remaining_hours}:@{AWS.token_remaining_minutes}>"
  string_inactive=""

  # The minute portion of the token's remaining validity will be shown
  # regardless of if it's active or not. However, if the remaining time
  # goes under a threshold of ten minutes, it will go active - and
  # change to a red colour.
  [AWS.token_remaining_minutes]
  colour_on="%{fg-red1}"
  colour_off=""
#+end_src


** Third-party Licenses

prompt2 is distributed under the GNU General Public License v3
(GPLv3), which allows users to use, modify, and distribute the
software, provided that all copies and derivatives remain under the
same license. This ensures that improvements and modifications to the
software remain free and accessible to the community.

This project includes the =etc/rgb.txt= file from Xorg, which is
licensed under the MIT License. The original license text for this
file can be found in the =etc/LICENSE_rgb.txt= file in this
repository.
